// Simple commands
// ===============

// show first 10 vertexes
g.V().limit(10)

// get first dataset
g.V().hasLabel('dataset').next()
// get first 2 datasets
g.V().hasLabel('dataset').next(2)
// show first or last 10 datasets
g.V().hasLabel('dataset').limit(10)
g.V().hasLabel('dataset').range(0, 10)
g.V().hasLabel('dataset').tail(10)
// show all, but first 10 datasets
g.V().hasLabel('dataset').range(10, -1)
g.V().hasLabel('dataset').skip(10)
// get first 10 datasets as list or set
g.V().hasLabel('dataset').limit(10).toList()
g.V().hasLabel('dataset').limit(10).toSet()
// also: repeat(), timelimit(), until()

// show their properties
g.V().hasLabel('dataset').limit(10).values()

// show some of their properties
g.V().hasLabel('dataset').limit(10).values('prodStep')

// convert results to List or Set
g.V().hasLabel('dataset').limit(10).values('prodStep').toList()
g.V().hasLabel('dataset').limit(10).values('prodStep').toSet()

// remove duplicated values and order results
g.V().hasLabel('dataset').limit(10).values('prodStep').dedup().order()

// BulkSet has more information
bs = g.V().hasLabel('dataset').limit(10).values('prodStep').toBulkSet()
bs.size()
bs.uniqueSize()
bs.asBulk()

// store results into existing variable
x = []
y = [] as Set
g.V().hasLabel('dataset').limit(10).values('prodStep').fill(x)
g.V().hasLabel('dataset').limit(10).values('prodStep').fill(y)

// show their properties as map
g.V().hasLabel('dataset').limit(10).valueMap().unfold()

// show label too
g.V().hasLabel('dataset').limit(10).valueMap(true).unfold()

// show some properties
g.V().hasLabel('dataset').limit(10).valueMap('name', 'imported')
g.V().hasLabel('dataset').limit(10).valueMap().select('name', 'imported')

// test if they have a property
g.V().hasLabel('dataset').limit(10).has('prodStep')
g.V().hasLabel('dataset').limit(10).hasNot('prodStep')

// put results into a variable (one or three results)
a = g.V().hasLabel('dataset').limit(10).valueMap().next()
b = g.V().hasLabel('dataset').limit(10).valueMap().next(3)
println b['name'][0]

// show statistics of values
g.V().hasLabel('dataset').limit(10).groupCount().by('prodStep')
g.V().label().groupCount()
g.V().groupCount().by(label)

// show mean, max, min number of events in a run datasets
g.V().has('run', 'number', 358031).out().values('nevents').mean()
g.V().has('run', 'number', 358031).out().values('nevents').max()
g.V().has('run', 'number', 358031).out().values('nevents').min()

// show datasets with more events or number of events in an interval
// see also is(), inside(), outside(), within(), without(), between()
g.V().has('run', 'number', 358031).out().has('nevents', gt(7180136)).values('name', 'nevents')
g.V().has('run', 'number', 358031).out().has('nevents', inside(7180136, 90026772)).values('name', 'nevents')

// show non-AOD datasets of a run
g.V().has('run', 'number', 358031).out().has('dataType', neq('AOD')).values('name')

// test several attributes with 'and', 'or' or 'not'
g.V().hasLabel('dataset').and(has('dataType', 'AOD'), has('prodStep', 'merge'))
g.V().hasLabel('dataset').has('dataType', 'AOD').and().has('prodStep', 'merge')
g.V().not(hasLabel('dataset')).count()
g.V().has(label, neq('dataset')).count()

// More complex navigation
// =======================

// show how many dataset each run has (relation: run -fills-> dataset)
g.V().hasLabel('run').group().by('number').by(out().hasLabel('dataset').count()).unfold()
g.V().hasLabel('run').group().by('number').by(outE().hasLabel('fills').count()).unfold()
g.V().hasLabel('run').group().by('number').by(out('fills').count()).unfold()
g.V().hasLabel('run').group().by('number').by(outE('fills').count()).unfold()

// show overlapping datasets
g.V().hasLabel('dataset').out('overlap').limit(10).path().by('name')

// is there an overlap bewtween two datasets ?
g.V().has('dataset', 'name', 'data18_13TeV.00358031.physics_Main.deriv.DAOD_HIGG2D1.f961_m2015_p3597').out('overlap').has('dataset', 'name', 'data18_13TeV.00358031.physics_Main.deriv.DAOD_HIGG1D1.f961_m2015_p3583').hasNext()

// all labels
g.V().groupCount().by(label).unfold().project('Label', 'Count').by(keys).by(values)
g.E().groupCount().by(label).unfold().project('Label', 'Count').by(keys).by(values)

// Also
// ====
// local(), coin(), sample()
// order(), order().by(), order().by(shuffle), order().by(decr), order(local), order().by(keys) 
// and(), or()

// Tricks
// ======

// prevent auto-iteration (in console)
g.V();null

// supress output
g.V().limit(10);[]

// show result object methods
g.V().hasLabel('dataset').limit(1).next().getClass().getMethods()

// read script from file
evaluate(new File("..."))

// profile a query
g....profile()

